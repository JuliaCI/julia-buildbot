from buildbot.schedulers.basic import AnyBranchScheduler, Dependent
from buildbot.schedulers.timed import Nightly
from buildbot.schedulers.triggerable import Triggerable
from buildbot.schedulers.forcesched import *
from buildbot.changes import filter
from buildbot.changes.pb import PBChangeSource
from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.source.bzr import Bzr
from buildbot.steps.shell import ShellCommand, SetPropertyFromCommand
from buildbot.steps.trigger import Trigger
from buildbot.steps.master import MasterShellCommand, SetProperty
from buildbot.process.properties import Property, Interpolate
from buildbot.steps.package.deb.pbuilder import DebPbuilder
from buildbot.steps.transfer import FileUpload, FileDownload
from buildbot.config import BuilderConfig
from buildbot.status import html
from buildbot.status.web import authz, auth
from buildbot.plugins import steps, util
try:
    from buildbot_secret import *
except:
    IOError('Could not load buildbot_secret.py! Ensure you have a buildbot_secret.py in this directory, and that it defines an ADMIN_USER and ADMIN_PASSWD variables!!')



# This is the dictionary that the buildmaster pays attention to. We use a the "c" alias because fingers.
c = BuildmasterConfig = {
    'protocols':{
        'pb': {
            'port': 9989
        }
    },
    'schedulers': [],
    'builders': [],
    'status': [],
    'title': "Julia",
    'titleURL': "http://julialang.org",
    'buildbotURL': "http://build.julialang.org:8010/",
    'db': {
        'db_url' : "sqlite:///state.sqlite",
    },
}


c['change_source'] = PBChangeSource(user='github', passwd='github.julialang42')


# Returns true if this is a build started from a tarball/dmg/zip packaging scheduler
def is_nightly_build(step):
    return step.getProperty('scheduler') == "Julia packager"

def is_osx(step):
    return 'osx' in step.getProperty('buildername')

def is_windows(step):
    return 'win' in step.getProperty('buildername')

def is_linux(step):
    return not is_osx(step) and not is_windows(step)

# Returns true if this is a build running on a builder that we should upload
# artifacts on, e.g. windows, osx, or linux tarball builders.  This explicitly
# excludes our ubuntu and (newer) centos builders, as those are just there to
# build and test, without uploading
def should_upload(step):
    return step.getProperty('buildername').startswith('package_')

def should_upload_latest(step):
    return should_upload(step) and is_nightly_build(step)

# Returns true if we should run coverage on this build; that is, if it
# was a nightly (not forced) build and it was 64-bit linux tarball build
def should_run_coverage(step):
    buildername = step.getProperty('buildername')
    return is_nightly_build(step) and buildername == 'package_tarball64'

# Load in our buildslave inventory
execfile("inventory.py")

# Load in the stuff for making OSX bottles
execfile("bottling.py")

# Load in packaging for various platforms
execfile("package.py")
execfile("package_launchpad.py")

# Load in juno signing builder
execfile("sign_juno.py")

# Load in manual RC builder forcing
execfile("rc_force.py")

# Load in nightly tasks such as building Homebrew, building against LLVM SVN, etc...
execfile("nightly_llvmsvn.py")
execfile("nightly_homebrew.py")
execfile("nightly_srpm.py")
execfile("nightly_threading.py")
execfile("nightly_gc_debug.py")

# Load in cleaning builders
execfile("nuclear_arsenal.py")

# Run coverage after generating tarballs
execfile("coverage.py")

authz_cfg=authz.Authz(
    auth=auth.BasicAuth([(ADMIN_USER,ADMIN_PASSWD)]),
    gracefulShutdown = 'auth',
    forceBuild = 'auth',
    forceAllBuilds = 'auth',
    pingBuilder = 'auth',
    stopBuild = 'auth',
    stopAllBuilds = 'auth',
    cancelPendingBuild = 'auth',
)
# Also setup Github hook here
c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg))
