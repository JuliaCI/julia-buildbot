from buildbot.plugins import *

try:
    from buildbot_secret import *
except:
    IOError('Could not load buildbot_secret.py! Ensure you have a buildbot_secret.py in this directory, and that it defines GITHUB_SECRET!')

# This is the dictionary that the buildmaster pays attention to. We use the "c" alias because fingers.
c = BuildmasterConfig = {
    'protocols':{
        'pb': {
            'port': 9989
        }
    },
    'schedulers': [],
    'builders': [],
    'status': [],
    'buildbotURL': 'https://buildtest.e.ip.saba.us/',
    'buildbotNetUsageData': 'full',
    'title': "Julia",
    'titleURL': "http://julialang.org",
    'db': {
        'db_url' : "postgresql://%s:%s@db/%s"%(db_user, db_password, db_user),
    },
    'www': {
        'port': 8010,

        # Setup GitHub change hook
        'change_hook_dialects': {
            'github': {
                'secret': GITHUB_WEBHOOK_SECRET,
                'strict': True,
            },
        },

        # Setup GitHub OAuth2 integration to allow anyone in the JuliaLang org to use the buildbot
        'auth': util.GitHubAuth(GITHUB_OAUTH_CLIENT_ID, GITHUB_OAUTH_CLIENT_SECRET),
        'authz': util.Authz(
            allowRules=[
                util.StopBuildEndpointMatcher(role="JuliaLang"),
                util.ForceBuildEndpointMatcher(role="JuliaLang"),
                util.RebuildBuildEndpointMatcher(role="JuliaLang"),
            ],
            roleMatchers=[
                util.RolesFromGroups(groupPrefix="")
            ],
        ),

        'plugins': {
            # Setup waterfall view
            'waterfall_view': {},

            # Setup console view
            'console_view': {},

            # Setup profiler
            'profiler': True,
        },
    }
}


# Returns true if this is a build started from a tarball/dmg/zip packaging scheduler
def is_nightly_build(props):
    return props.getProperty('scheduler') == "Julia packager"

def is_osx(props):
    return 'osx' in props.getProperty('buildername')

# One day, my boy.  One day.  Until then, ask `is_osx()`
def is_mac(props):
    return is_osx(props)

def is_windows(props):
    return 'win' in props.getProperty('buildername')

def is_linux(props):
    return not is_mac(props) and not is_windows(props)

def get_os_name(props):
    if is_windows(props):
        return "winnt"
    elif is_mac(props):
        return "mac"
    else:
        return "linux"

# Returns true if this is a build running on a builder that we should upload
# artifacts on, e.g. windows, osx, or linux tarball builders.  This explicitly
# excludes our ubuntu and (newer) centos builders, as those are just there to
# build and test, without uploading
def should_upload(props):
    return props.getProperty('buildername').startswith('package_')

def should_upload_latest(props):
    return should_upload(props) and is_nightly_build(props)

# Returns true if we should run coverage on this build; that is, if it
# was a nightly (not forced) build and it was 64-bit linux tarball build
def should_run_coverage(props):
    buildername = props.getProperty('buildername')
    return is_nightly_build(props) and buildername == 'package_tarball64'

# Returns a  dictionary mapping Properties that we can use in str.format()
def props_obj_to_dict(props_obj):
    props = props_obj.getProperties().asDict()
    return {k: props[k][0] for k in props}


# Load in our buildworker inventory
exec(open("inventory.py").read())

# Load in useful utilities for dealing with builders
exec(open("builder_utils.py").read())

# Load in the stuff for making OSX bottles
exec(open("bottling.py").read())

# Load in packaging for various platforms
exec(open("package.py").read())
exec(open("package_launchpad.py").read())

# Load in juno signing builder
exec(open("sign_juno.py").read())

# Load in code-executor
exec(open("run_code.py").read())

# Load in nightly tasks such as building Homebrew, building against LLVM SVN, etc...
exec(open("nightly_llvmsvn.py").read())
exec(open("nightly_homebrew.py").read())
exec(open("nightly_srpm.py").read())
exec(open("nightly_threading.py").read())
exec(open("nightly_gc_debug.py").read())
exec(open("nightly_separated_testing.py").read())

# Load in cleaning builders
exec(open("nuclear_arsenal.py").read())

# Run coverage after generating tarballs
exec(open("coverage.py").read())

# Enable auto-reloads from github
exec(open("auto_reload.py").read())
